package org.knoesis.semanticweb.rdf.jena.sp.converter;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.apache.jena.graph.Node;
import org.apache.jena.graph.NodeFactory;
import org.apache.log4j.Logger;
import org.knoesis.semanticweb.rdf.jena.sp.parser.Parser;
import org.knoesis.semanticweb.rdf.jena.sp.parser.QuadParser;
import org.knoesis.semanticweb.rdf.jena.sp.parser.TripleParser;
import org.knoesis.semanticweb.rdf.utils.*;

/*	Subclasses: 
 * 		NamedGraph2SP
 * 			Input: a property specifying the relationship between the triple and the graph
 * 		NanoPub2SP
 * 		Rei2SP
 * 		Triple2SP
 * 			Input: a metadata resource and a property specifying the relationship between the triple and the metadata
 * 	Default rep conversion is triple cleaning and return it as it is 
 * */

public class ContextualRepresentationConverter {
	
	final static Logger logger = Logger.getLogger(ContextualRepresentationConverter.class);

	private String prefixesFile = "prefixes.ttl";

	protected long initUUIDNumber = -1;
	protected String initUUIDPrefix = null;

	protected String spDelimiter;
	protected Node singletonPropertyOf = NodeFactory.createURI(Constants.SINGLETON_PROPERTY_OF);


	public ContextualRepresentationConverter(){
		initUUIDNumber = System.currentTimeMillis();
		spDelimiter = "_";
		initUUIDPrefix = "sp";
		
		RDFWriteUtils.loadPrefixes(this.prefixesFile);
	}
	
	public ContextualRepresentationConverter(long spPrefixNum, String spPrefixStr, String spDelimiter, String singletonPropertyOfURI){
		this.setInitUUIDNumber(spPrefixNum);
		this.setInitUUIDPrefix(spPrefixStr);
		this.setSPDelimiter(spDelimiter);
		this.singletonPropertyOf = NodeFactory.createURI(singletonPropertyOfURI);
		
		RDFWriteUtils.loadPrefixes(this.prefixesFile);
	}
	
	public void convert(String file, String ext, String rep) {
		
		// If the input is a file
		if (!Files.isDirectory(Paths.get(file))){
			try {
				String fileOut = genFileOut(file, ext);

				long start = System.currentTimeMillis();
				
				convertFile(file, fileOut, ext, rep);
				
				long end = System.currentTimeMillis() - start;
				
				System.out.println("Time\t" + file + "\t" + end);
				
				System.out.println("Size\t" + file + "\t" + Paths.get(file).toFile().length() + "\t" + fileOut + "\t" + Paths.get(fileOut).toFile().length());

			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
			
		} else {
			// If the input is a directory

			// Create a new directory for output files
			try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(file))) {
				String dirOut = file + (ext.equals(Constants.NTRIPLE_EXT)?Constants.CONVERTED_TO_SP_NT:Constants.CONVERTED_TO_SP_TTL);
				Files.createDirectories(Paths.get(dirOut));
		        
				String fileOut = null;
				
				/* PROCESS EACH INPUT FILE & GENERATE OUTPUT FILE */
				for (Path entry : stream) {
					fileOut = dirOut + "/" + genFileOut(entry.getFileName().toString(), ext);

					long start = System.currentTimeMillis();
		        	
					convertFile(entry.toString(), fileOut, ext, rep);
					
		        	long end = System.currentTimeMillis() - start;

					System.out.println("Time(s)\t" + entry.toString() + "\t" + end);
					
					System.out.println("Size(mb)\t" + entry.toString() + "\t" + Paths.get(entry.toString()).toFile().length() + "\t" + fileOut + "\t" + Paths.get(fileOut).toFile().length());
		        }
		    } catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
				
		}
	
	}
	
	
	public void convertFile(String file, String out, String ext, String rep) throws FileNotFoundException {

		System.out.println("Processing " + file + " to generate file " + out );

		// Parse the file to read and process every line
		if (file != null) {
			InputStream stream = new FileInputStream(file);

			try {
//				String fileOut = genFileOut(out, ext);
				File f = new File(out);
				if(!f.exists())
				    f.createNewFile();
				
				// Write the credentials
				String cred = "# This file is generated by SP-Conversion.\n";
				Files.write(Paths.get(out), cred.getBytes());
				
				// Write the prefixes if ttl
				if (ext.equalsIgnoreCase(Constants.TURTLE_EXT)) {
					RDFWriteUtils.resetPrefixMapping();
				}
				Parser nxp = null;
				switch (rep.toUpperCase()) {
				case Constants.NG_REP:
					nxp = new QuadParser();
					break;
				case Constants.NANO_REP:
					nxp = new QuadParser();
					break;
				case Constants.REI_REP:
					nxp = new TripleParser();
					break;
				case Constants.TRIPLE_REP:
					nxp = new TripleParser();
					break;
				default:
					nxp = new TripleParser();
					break;
				}
				
				nxp.parse(this, file, out, ext);
				stream.close();
	
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
		}
	}
		

	public String transform(Node[] nodes, String ext) {
				
		/* REI/TRIPLE to TURTLE/NTRIPLE*/
		
		switch (ext.toLowerCase()) {

		/* NANO TO NTRIPLE */
		case Constants.NTRIPLE_EXT:
			
			return RDFWriteUtils.Triple2NT(nodes);
			
		/* NANO TO TURTLE */

		case Constants.TURTLE_EXT:
			
			return RDFWriteUtils.Triple2N3(nodes);

		}
		return "";
	}
	

	protected String genFileOut(String in, String ext){
		if (in != null) {
			
			return in.split("\\.")[0] + Constants.SP_FILE_SUFFIX + "." + ext.toLowerCase();
		}
		return in;
		
	}

	public void setSPDelimiter(String delimiter){
		this.spDelimiter = delimiter;
	}
	
	public String getSPDelimiter(){
		return this.spDelimiter;
	}
	
	public void setInitUUIDPrefix(String pre){
		this.initUUIDPrefix = pre;
	}
	
	public String getInitUUIDPrefix(){
		return this.initUUIDPrefix;
	}
	
	public void setInitUUIDNumber(long num){
		this.initUUIDNumber = num;
	}

	public long getInitUUIDNumber(){
		return this.initUUIDNumber;
	}
	
	protected String getNextUUID(){
		StringBuilder uuid = new StringBuilder(this.spDelimiter);
		uuid.append(initUUIDPrefix);
		uuid.append(this.spDelimiter);
		uuid.append(this.initUUIDNumber);
		this.initUUIDNumber++;
		
		return uuid.toString();
	}


	public Node getSingletonPropertyOf() {
		return singletonPropertyOf;
	}


	public void setSingletonPropertyOf(Node singletonPropertyOf) {
		this.singletonPropertyOf = singletonPropertyOf;
	}
	
	public void setSingletonPropertyOf(String singletonPropertyOf) {
		this.singletonPropertyOf = NodeFactory.createURI(singletonPropertyOf);
	}
}
